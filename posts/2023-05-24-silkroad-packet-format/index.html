<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=robots content="index, follow"><meta name=author content><meta name=description content><link rel=author type=text/plain href=/humans.txt><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><link rel=mask-icon href=/safari-pinned-tab.svg color=#494f5c><meta itemprop=name content="Silkroad Online Network Protocol - an introduction"><meta itemprop=description content="This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my skrillax emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.
When designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn’t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by Silkroad Online, but first lets go over some basics."><meta itemprop=datePublished content="2025-02-09T10:00:00+02:00"><meta itemprop=dateModified content="2025-02-09T10:00:00+02:00"><meta itemprop=wordCount content="1958"><meta itemprop=keywords content="Silkroad,Skrillax"><meta property="og:url" content="https://blog.eternalwings.de/posts/2023-05-24-silkroad-packet-format/"><meta property="og:site_name" content="Re: boot"><meta property="og:title" content="Silkroad Online Network Protocol - an introduction"><meta property="og:description" content="This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my skrillax emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.
When designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn’t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by Silkroad Online, but first lets go over some basics."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-09T10:00:00+02:00"><meta property="article:modified_time" content="2025-02-09T10:00:00+02:00"><meta property="article:tag" content="Silkroad"><meta property="article:tag" content="Skrillax"><meta name=twitter:card content="summary"><meta name=twitter:title content="Silkroad Online Network Protocol - an introduction"><meta name=twitter:description content="This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my skrillax emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.
When designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn’t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by Silkroad Online, but first lets go over some basics."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Silkroad Online Network Protocol - an introduction","name":"Silkroad Online Network Protocol - an introduction","description":"This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my skrillax emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.\nWhen designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn\u0026rsquo;t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by Silkroad Online, but first lets go over some basics.\n","keywords":["silkroad","Skrillax"],"articleBody":"This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my skrillax emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.\nWhen designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn’t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by Silkroad Online, but first lets go over some basics.\nNetwork Protocols A network protocol is the schema two parties use to communicate with each other and exchange information. Otherwise, each party would receive a bunch of bytes that they wouldn’t know how to use. Just like how a file is essentially just random bytes to anyone unless they know the file format.\nBasic Block: Frames An important building block for network protocols is a basic message, or: frame. It’s essentially the most minimal structure of anything in the protocol. Anything less and there’d be not enough data to be useful and anything more you’d end up with too much situational data. Essentially, once something applies to all messages of a protocol, it’s part of the frame. Common things that show up in a frame are the length of the content or the frame itself, and something like a message type. The length is necessary as most underlying protocols (such as TCP) may split one of your frames and spread it over multiple packets or actually send multiple frames inside one packet and the other side needs to know when a frame over in both of these cases. Providing the length, instead of using - e.g. - a delimiter, makes it easier for the receiver to allocate appropriate amounts of memory as it is now possible to know this before reading possibly large amounts of bytes. A kind of message type would define what is to be expected inside the frame, which may have a more complicated structure.\nSilkroad does have a pretty decent frame structure:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Length | Opcode | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Counter | CRC | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ + | | + Data + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ As you can see, it contains very little additional data, but it does contain enough to let a receiver separate the stream of bytes it receives into separate messages. The length specifies the length of the data contained in it, but since the header of the frame has a known length, we can easily calculate the total size of a frame. CRC is a checksum of the content to ensure a bit didn’t flip on accident and Counter is a to protect against replay attacks. Both of these are only really sent by the client. The data itself is variable length and depends on the opcode. That opcode specifies what is actually contained in this frame, i.e. the operation to be performed by this packet.\nSo far so good, but this is not the full story. Silkroad does support encryption of packets so that, for example, the login credentials don’t get sent as plain bytes. In Silkroad this is done by masking the Length info with 0x8000, such that:\nconst is_encrypted = (length \u0026 0x8000) != 0; The remainder of the frame, including the rest of the header, is then encrypted. One might assume that Length would now identify the encrypted length of the frame, but that would be incorrect. The Length is actually still the length of the cleartext content. That means you need to calculate the encrypted size yourself to figure out how many bytes you’ll need to read. Depending on the encryption there might be a 1-to-1 relationship in size or a block cipher is used and is thus a multiple of the block size.\nSikroad is using an old, but still secure1 cipher: blowfish2. Blowfish has a block length of 8 bytes. If the content + header is smaller than a multiple of 8 bytes, it will be padded to match the 8 byte block length - standard stuff. Thus, the calculation for the length would be something like:\n// Since the header is also encrypted, we need to account for that by adding 4. const content_length = length + 4; // `(8 - (content_length % 8))` will return the missing bytes to fill the next 8 byte // block for blowfish. const padded_length = content_length + (8 - (content_length % 8)) Assuming, of course, we actually have an encrypted packet. With padded_length + 2 we now know the final size of the frame sent. To actually read the content, one would have to know the encryption key. That’s for another time - for now we assume we have established a shared secret already.\nWith this, we can segment every packet stream sent across the wire between the Silkroad client and a server. If you’d rather not write this yourself, you can take a look at my skrillax-codec crate, which can handle this for you.\nEncryption To also be able to decrypt/encrypt packets, we need to first do a handshake. After the handshake both parties (server and client) will end up with the same shared secret. In the case of Silkroad Online, the server will start the handshake as the first thing when a connection has been established. In most cases, the server requires this handshake to be completed before continuing with the connection and is therefor vital to get correct. The handshake uses the normal frames, which we’ve established now, to convey the operations done in the handshake. The flow for the handshake is as follows:\nsequenceDiagram participant Client participant Server Server -\u003e\u003e Client: Public Server Seeds Client -\u003e\u003e Server: Mixed Public Client Seeds Server -\u003e\u003e Client: Verify Key Client -\u003e\u003e Server: Finish This is very reminiscient of a Diffie-Hellman key exchange, just a bit homegrown. Maybe they should’ve done that, because due to their setup, they ended up with only 31 bits of actually private material. This is comparatively easy to break on modern systems, taking less than a minute on most desktop computers. So if the key exchange is observed, it is possible to decrypt all packets sent between the client and server for that connection. I actually wrote a tool that does it automatically for any pcap file, which you can find in my skrillax repo3.\nI won’t cover more details here of what is exactly exchanged in which packet - you can look at the documentation compiled by DaxterSoul, originally written by pushedx. I’d assume most implementations are at least in part based on that documentation; including mine.\nPacket data To actually read and write the necessary packets in the handshake, we need to know how we can read the bytes inside a packet. Unlike a self-describing format, if you don’t know the structure of the data contained in a packet, you won’t be able to parse the packet into a usable structure. Just like how you wouldn’t which bytes make up which pixels in an image file without also knowing the format, like png or jpg. And obviously Joymax is not interested in publishing a spec for the individual packets, so it’s up to reverse engineering to figure out what the structure could be - for each individual operation. Though there are obviously patterns that one can look for.\nA thing of note here is Silkroad uses little-endian notation, even though in networking it’s usually more common to use big-endian notation. But with that in mind, we can find most C data types to be represented as their binary in-memory representation, just with little-endian notation. This includes bool (1 byte), char (1 byte), short (2 bytes), int (4 bytes), and float (4 bytes). As example, the short 1337, or 0x0539 in hex, would be represented as [0x39, 0x05] in the packet data. But that is about as much as we can expect; without the self-describing nature, we won’t see patterns like field separators or type IDs to show up and help us. Yet, one could feasibly expect that Silkroad isn’t just shoving bytes into packets with a clear idea of structure. And most certainly they are serializing their C/C++ structs into packets, just the structure is lost in translation. In other words, the following struct:\nstruct Position { short x; short y; }; struct Position pos = { .x = 1641, .y = 3732 }; would end up serialized in the packet data as:\n0x69 0x06 0x94 0x0E Without the structure, this might as well be 4 single byte values or one int value (244581993) - it all depends on the expected structure. There are some things that hint at the size, but these are never a guaranteed indicator. For example, the following byte stream:\n0x01 0x80 0x00 0x00 0x80 could hint at an int followed by a char/byte, due to the zero bytes being the higher bits of a small number represented by the int. But it might as well be a bool followed by an int. You literally cannot tell just by looking at the bytes alone without context, which makes reverse engineering not a simple task.\nLets move on for now and look at a more complex “basic” type: a string. While in C, a string is just a series of bytes until a null-byte, it is something that is inherently variable in length. On the reading side, we’d prefer if we could know the length ahead of time. Thus, we’re nice and start with the length as a short, followed by each character, excluding the null byte. Because of the explicit length, there’s no need for a null-byte as a terminator. Thankfully, strings are one of the easier structures to figure out, as most tools display the ascii equivalents next to hex values. Ignoring the 0x04 byte for now, we can see the length as [0x08 0x00] - so 8 - followed by the text, now clearly visible: ‘Skrillax’.\nThere are even more of such structures, of course, but lets explore them another time.\nClosing With this, you should now be able to read and understand the protocol at a basic level. You can check the structure of known packets on the wiki[1][2][3], though they are for an old version of the game (v1.188). You can also take a look at skrillax-network which handles all the network related stuff for you, including serialization and deserialization. There’s even a mini client example that will print out all current notices if you want something you can try out yourself right now.\nDue to an oversight in the key exchange used in Silkroad it is, however, relatively easy to brute force the secret key. ↩︎\nMore accurately, it’s using a version known as “blowfish compat”, which is blowfish with different endianness. ↩︎\nI restructured the emulator, causing the decryptor to end up nowhere so this is a deep link into the repo for now. I’m trying to find a good way to put it in a new repo as a standalone thing somewhere. ↩︎\n","wordCount":"1958","inLanguage":"en","datePublished":"2025-02-09T10:00:00+02:00","dateModified":"2025-02-09T10:00:00+02:00","author":{"@type":"Person","name":null},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.eternalwings.de/posts/2023-05-24-silkroad-packet-format/"},"publisher":{"@type":"Organization","name":"Re: boot","description":"","logo":{"@type":"ImageObject","url":"https://blog.eternalwings.de/favicon.ico"}}}</script><title>Silkroad Online Network Protocol - an introduction</title>
<link rel="stylesheet dns-prefetch preconnect preload prefetch" as=style href=https://blog.eternalwings.de/css/style.min.d3facc2d5fe42af72ee5a80584900a45ffee6035df0ef582bd8696c2fe0c9da5.css integrity="sha256-0/rMLV/kKvcu5agFhJAKRf/uYDXfDvWCvYaWwv4MnaU=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://blog.eternalwings.de/>Re: boot</a></div><nav class="site-nav hide-in-mobile"><a href=https://blog.eternalwings.de/about>About</a><a href=https://blog.eternalwings.de/posts/>Posts</a><a href=https://blog.eternalwings.de/projects/>Projects</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-links hide-in-mobile"><a href=https://twitter.com/kumpelblase2 target=_blank rel="noopener me" title=Twitter><svg class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://chaos.social/kumpelblase2 target=_blank rel="noopener me" title=Mastodon><svg class="feather" width="24" height="24" fill="none" stroke="currentcolor" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.474 13.998c-.296 1.526-2.655 3.194-5.365 3.519-1.413.168-2.804.323-4.287.255-2.426-.111-4.34-.579-4.34-.579.0.236.015.461.044.672.316 2.394 2.373 2.537 4.323 2.604 1.968.067 3.721-.486 3.721-.486l.081 1.779s-1.377.739-3.829.875c-1.352.075-3.031-.034-4.987-.551-4.241-1.123-4.97-5.644-5.083-10.231C1.719 10.493 1.741 9.209 1.741 8.134c0-4.691 3.073-6.065 3.073-6.065 1.549-.713 4.208-1.013 6.973-1.034h.067c2.764.022 5.426.322 6.975 1.033.0.0 3.073 1.375 3.073 6.066.0.0.039 3.461-.428 5.864"/><path d="M6.464 13.231V7.973c0-1.002.549-2.613 2.613-2.613 2.064.0 2.741 1.793 2.741 3.484.0 1.692.0 2.23.0 2.23"/><path d="M17.173 13.231V7.973c0-1.002-.549-2.613-2.613-2.613s-2.741 1.793-2.741 3.484c0 1.692.0 2.23.0 2.23"/></svg></a><a href=https://github.com/kumpelblase2 target=_blank rel="noopener me" title=Github><svg class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://keybase.io/kumpelblase2 target=_blank rel="noopener me" title=Keybase><svg class="feather feather-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></span><button id=menu-btn class=hdr-btn title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://blog.eternalwings.de/about>About</a></li><li><a href=https://blog.eternalwings.de/posts/>Posts</a></li><li><a href=https://blog.eternalwings.de/projects/>Projects</a></li></ul></div><main class="site-main section-inner animated fadeIn faster"><article class=thin><header class=post-header><div class=post-date><span>2025/02/09</span></div><h1>Silkroad Online Network Protocol - an introduction</h1></header><div class=post-description><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://blog.eternalwings.de/tags/silkroad>silkroad</a></span><span class=tag><a href=https://blog.eternalwings.de/tags/skrillax>Skrillax</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1958Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2025/02/09 08:00 +0000</p></div><hr class=post-end><div class=content><p>This is a series of posts about Silkroad Online or, more specifically, about things I encounter when writing my <a href=https://github.com/kumpelblase2/skrillax>skrillax</a> emulator for it. To lay the foundation making the later parts understandable, this introduction provides the basics of the network protocol used in Silkroad Online. None of this is really new information and is simply compiled to provide a self contained explanation.</p><p>When designing a (network) protocol, there are a few things you want to strive for. One of the being avoiding ambiguity and another being consistency. You wouldn&rsquo;t want a packet to be parsed differently, depending on the time of day. Or if you want to represent a concept, like a list of something, to be encoded in several different ways. This makes it significantly easier to parse and work with as it allows for a single, simple parsing pass and better reuse of code across different areas. In the following I want to look closer that the protocol used by <a href=https://www.joymax.com/SilKRoaD/>Silkroad Online</a>, but first lets go over some basics.</p><h2 id=network-protocols>Network Protocols<a href=#network-protocols class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>A network protocol is the schema two parties use to communicate with each other and exchange information. Otherwise, each party would receive a bunch of bytes that they wouldn&rsquo;t know how to use. Just like how a file is essentially just random bytes to anyone unless they know the file format.</p><h2 id=basic-block-frames>Basic Block: Frames<a href=#basic-block-frames class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>An important building block for network protocols is a basic message, or: frame. It&rsquo;s essentially the most minimal structure of anything in the protocol. Anything less and there&rsquo;d be not enough data to be useful and anything more you&rsquo;d end up with too much situational data. Essentially, once something applies to <em>all</em> messages of a protocol, it&rsquo;s part of the frame. Common things that show up in a frame are the length of the content or the frame itself, and something like a message type. The length is necessary as most underlying protocols (such as TCP) may split one of your frames and spread it over multiple packets or actually send multiple frames inside one packet and the other side needs to know when a frame over in both of these cases. Providing the length, instead of using - e.g. - a delimiter, makes it easier for the receiver to allocate appropriate amounts of memory as it is now possible to know this before reading possibly large amounts of bytes. A kind of message type would define what is to be expected inside the frame, which may have a more complicated structure.</p><p>Silkroad does have a pretty decent frame structure:</p><div class=highlight title="Silkroad Frame"><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl> 0                   1                   2                   3  
</span></span><span class=line><span class=cl> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class=line><span class=cl>|             Length            |             Opcode            |
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class=line><span class=cl>|    Counter    |      CRC      |                               |
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
</span></span><span class=line><span class=cl>|                                                               |
</span></span><span class=line><span class=cl>+                              Data                             +
</span></span><span class=line><span class=cl>|                                                               |
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></code></pre></div><p>As you can see, it contains very little additional data, but it does contain enough to let a receiver separate the stream of bytes it receives into separate messages. The length specifies the length of the data contained in it, but since the header of the frame has a known length, we can easily calculate the total size of a frame. CRC is a checksum of the content to ensure a bit didn&rsquo;t flip on accident and Counter is a to protect against replay attacks. Both of these are only really sent by the client. The data itself is variable length and depends on the opcode. That opcode specifies what is actually contained in this frame, i.e. the operation to be performed by this packet.</p><p>So far so good, but this is not the full story. Silkroad does support encryption of packets so that, for example, the login credentials don&rsquo;t get sent as plain bytes. In Silkroad this is done by masking the <code>Length</code> info with <code>0x8000</code>, such that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>is_encrypted</span> <span class=o>=</span> <span class=p>(</span><span class=nx>length</span> <span class=o>&amp;</span> <span class=mh>0x8000</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div><p>The remainder of the frame, including the rest of the header, is then encrypted. One might assume that <code>Length</code> would now identify the encrypted length of the frame, but that would be incorrect. The <code>Length</code> is actually still the length of the cleartext content. That means you need to calculate the encrypted size yourself to figure out how many bytes you&rsquo;ll need to read. Depending on the encryption there might be a 1-to-1 relationship in size <em>or</em> a block cipher is used and is thus a multiple of the block size.</p><p>Sikroad is using an old, but still secure<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> cipher: <code>blowfish</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Blowfish has a block length of 8 bytes. If the content + header is smaller than a multiple of 8 bytes, it will be padded to match the 8 byte block length - standard stuff. Thus, the calculation for the length would be something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Since the header is also encrypted, we need to account for that by adding 4. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>content_length</span> <span class=o>=</span> <span class=nx>length</span> <span class=o>+</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// `(8 - (content_length % 8))` will return the missing bytes to fill the next 8 byte
</span></span></span><span class=line><span class=cl><span class=c1>// block for blowfish.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>padded_length</span> <span class=o>=</span> <span class=nx>content_length</span> <span class=o>+</span> <span class=p>(</span><span class=mi>8</span> <span class=o>-</span> <span class=p>(</span><span class=nx>content_length</span> <span class=o>%</span> <span class=mi>8</span><span class=p>))</span>
</span></span></code></pre></div><p>Assuming, of course, we actually have an encrypted packet. With <code>padded_length + 2</code> we now know the final size of the frame sent. To actually read the content, one would have to know the encryption key. That&rsquo;s for another time - for now we assume we have established a shared secret already.</p><p>With this, we can segment every packet stream sent across the wire between the Silkroad client and a server. If you&rsquo;d rather not write this yourself, you can take a look at my <a href=https://crates.io/crates/skrillax-codec>skrillax-codec</a> crate, which can handle this for you.</p><h2 id=encryption>Encryption<a href=#encryption class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>To also be able to decrypt/encrypt packets, we need to first do a handshake. After the handshake both parties (server and client) will end up with the same shared secret. In the case of Silkroad Online, the server will start the handshake as the first thing when a connection has been established. In most cases, the server requires this handshake to be completed before continuing with the connection and is therefor vital to get correct. The handshake uses the normal frames, which we&rsquo;ve established now, to convey the operations done in the handshake. The flow for the handshake is as follows:</p><pre class=mermaid>sequenceDiagram
  participant Client
  participant Server
  Server ->> Client: Public Server Seeds
  Client ->> Server: Mixed Public Client Seeds
  Server ->> Client: Verify Key
  Client ->> Server: Finish
</pre><p>This is very reminiscient of a <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>Diffie-Hellman key exchange</a>, just a bit homegrown. Maybe they should&rsquo;ve done that, because due to their setup, they ended up with only 31 bits of actually private material. This is comparatively easy to break on modern systems, taking less than a minute on most desktop computers. So if the key exchange is observed, it is possible to decrypt all packets sent between the client and server for that connection. I actually wrote a tool that does it automatically for any pcap file, which you can find in my <a href=https://github.com/kumpelblase2/skrillax/tree/9d8d5384e2178c6f0f2ba80984284583da901e7c/silkroad-packet-decryptor>skrillax repo</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>I won&rsquo;t cover more details here of what is exactly exchanged in which packet - you can look at the <a href=https://github.com/DummkopfOfHachtenduden/SilkroadDoc/wiki/silkroad-security>documentation</a> compiled by DaxterSoul, originally written by pushedx. I&rsquo;d assume most implementations are at least in part based on that documentation; including <a href=https://github.com/kumpelblase2/skrillax-network/tree/master/crates/skrillax-security>mine</a>.</p><h2 id=packet-data>Packet data<a href=#packet-data class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>To actually read and write the necessary packets in the handshake, we need to know how we can read the bytes inside a packet. Unlike a self-describing format, if you don&rsquo;t know the structure of the data contained in a packet, you won&rsquo;t be able to parse the packet into a usable structure. Just like how you wouldn&rsquo;t which bytes make up which pixels in an image file without also knowing the format, like png or jpg. And obviously Joymax is not interested in publishing a spec for the individual packets, so it&rsquo;s up to reverse engineering to figure out what the structure could be - for each individual operation. Though there are obviously patterns that one can look for.</p><p>A thing of note here is Silkroad uses <a href=https://en.wikipedia.org/wiki/Endianness>little-endian notation</a>, even though in networking it&rsquo;s usually more common to use <a href=https://datatracker.ietf.org/doc/html/rfc1700#page-3>big-endian notation</a>. But with that in mind, we can find most C data types to be represented as their binary in-memory representation, just with little-endian notation. This includes <code>bool</code> (1 byte), <code>char</code> (1 byte), short (2 bytes), int (4 bytes), and float (4 bytes). As example, the short <code>1337</code>, or <code>0x0539</code> in hex, would be represented as <code>[0x39, 0x05]</code> in the packet data. But that is about as much as we can expect; without the self-describing nature, we won&rsquo;t see patterns like field separators or type IDs to show up and help us. Yet, one could feasibly expect that Silkroad isn&rsquo;t just shoving bytes into packets with a clear idea of structure. And most certainly they are serializing their C/C++ structs into packets, just the structure is lost in translation. In other words, the following struct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Position</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>short</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>short</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>Position</span> <span class=n>pos</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1641</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>3732</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>would end up serialized in the packet data as:</p><pre tabindex=0><code>0x69 0x06 0x94 0x0E
</code></pre><p>Without the structure, this might as well be 4 single byte values or one <code>int</code> value (<code>244581993</code>) - it all depends on the expected structure. There are some things that hint at the size, but these are never a guaranteed indicator. For example, the following byte stream:</p><pre tabindex=0><code>0x01 0x80 0x00 0x00 0x80
</code></pre><p><em>could</em> hint at an <code>int</code> followed by a <code>char</code>/<code>byte</code>, due to the zero bytes being the higher bits of a small number represented by the <code>int</code>. But it might as well be a <code>bool</code> followed by an <code>int</code>. You literally cannot tell just by looking at the bytes alone without context, which makes reverse engineering not a simple task.</p><p>Lets move on for now and look at a more complex &ldquo;basic&rdquo; type: a string. While in C, a string is just a series of bytes until a null-byte, it is something that is inherently variable in length. On the reading side, we&rsquo;d prefer if we could know the length ahead of time. Thus, we&rsquo;re nice and start with the length as a <code>short</code>, followed by each character, <em>excluding</em> the null byte. Because of the explicit length, there&rsquo;s no need for a null-byte as a terminator. Thankfully, strings are one of the easier structures to figure out, as most tools display the ascii equivalents next to hex values.
<img src=/string-data-example.png alt="Example String Sequence, showing a 2 byte length followed by the characters for &lsquo;Skrillax&rsquo;">
Ignoring the <code>0x04</code> byte for now, we can see the length as <code>[0x08 0x00]</code> - so 8 - followed by the text, now clearly visible: &lsquo;Skrillax&rsquo;.</p><p>There are even more of such structures, of course, but lets explore them another time.</p><h2 id=closing>Closing<a href=#closing class=anchor aria-hidden=true><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>With this, you should now be able to read and understand the protocol at a basic level. You can check the structure of known packets on the wiki<a href=https://github.com/DummkopfOfHachtenduden/SilkroadDoc/wiki/Global-packets>[1]</a><a href=https://github.com/DummkopfOfHachtenduden/SilkroadDoc/wiki/Gateway-packets>[2]</a><a href=https://github.com/DummkopfOfHachtenduden/SilkroadDoc/wiki/Agent-packets>[3]</a>, though they are for an old version of the game (v1.188). You can also take a look at <a href=https://github.com/kumpelblase2/skrillax-network>skrillax-network</a> which handles all the network related stuff for you, including serialization and deserialization. There&rsquo;s even a <a href=https://github.com/kumpelblase2/skrillax-network/tree/master/examples/simple-official-client>mini client example</a> that will print out all current notices if you want something you can try out yourself right now.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Due to an oversight in the key exchange used in Silkroad it is, however, relatively easy to brute force the secret key.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>More accurately, it&rsquo;s using a version known as &ldquo;blowfish compat&rdquo;, which is blowfish with different endianness.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>I restructured the emulator, causing the decryptor to end up nowhere so this is a deep link into the repo for now. I&rsquo;m trying to find a good way to put it in a new repo as a standalone thing somewhere.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><div class="post-nav thin"><a class=prev-post href=https://blog.eternalwings.de/posts/2019-12-11-its-been-a-long-time/><span class=post-nav-label>Older&nbsp;<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Its Been a Long Time</span></a></div><div id=comments class=thin></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2025 <a href=https://blog.eternalwings.de/>Re: boot</a>
&#183; &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a>&#183; Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>
&#183; Theme <a href=https://github.com/1bl4z3r/hermit-V2 target=_blank rel=noopener>Hermit-V2</a></p></footer><script async src=https://blog.eternalwings.de/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin=anonymous></script><script defer async type=module>
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true,theme: 'dark' });
    </script></body></html>